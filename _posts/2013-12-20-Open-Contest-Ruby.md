---
layout: default
title: オープンコンテストをRubyで解いてみた
---

## はじめに

この記事は[SLP Advent Calendar 2013](http://www.adventar.org/calendars/215) 20日目の記事です。  
いろいろあったんです… # いろんなところでトラブったりトラブったり…

ネタにも困っていたので思いつきで1年生がC言語で解いているオープンコンテストをRubyでやってみることにしました。

## オープンコンテスト

皆さん(関係者)ご存知のオープンコンテスト。某先生によるC言語学習のためのプログラミングコンテストですね。
自分自身を含め、受けた経験のある人に話を聞くと大抵難しいという回答が得られます…。  
 # 問題とかではなくて、主に日本語 ですが 独特？癖のある？表現や見聞きしたことのない単語がよく出てきますしねぇ。
C言語の基本的な構文を扱う問題なだけのはずなんですが、問題にひねりがあったり数学的な要素が入ってきたりして毎年苦戦している人も多いように見える。

テキトーに聞いて回ったところ、今やっている範囲で難しいのは
枠付カレンダーを出力する問題らしい。 
これは、ループ系制御構造を扱い、特にbeak,continueを対象とした問題。
この問題を解いてみることにする。

## 枠付きカレンダー問題概要

### 入力

`2011 9` のように年と月が与えられる。  
入力される年と月にはそれぞれ制限があり  
年は 2000-3000、 月は 1-12 とのこと。

### 出力

問題名のとおり、次の様な枠付カレンダーの出力

```text
|日|月|火|水|木|金|土|
|  |  |  |  | 1| 2| 3|
| 4| 5| 6| 7| 8| 9|10|
|11|12|13|14|15|16|17|
|18|19|20|21|22|23|24|
|25|26|27|28|29|30|  |
```

### その他

前提として、2000年1月1日が土曜日という情報が与えられている。  
この情報をもとに、0-6の曜日コード(0が日曜、6が土曜)を算出、利用しカレンダーの空枠を含めて出力する。  
そのために基準の日となる2000年1月1日からの入力された月の初日までの累積日数を計算する必要がある。  
 #現在取り組んでいる1年生にとっては、累積に吸うの計算や、空枠出力の調整に苦労するパターンが多いのかなと予想。


## C言語による解答

…を載せようと思ったのですが、解答済みでない人がいるかもしれないとか、模範解答(らしきものを)公開していいのかと、微妙だったのでとりあえず控えておきます。

といっても、何も情報ださないわけには行かないので…行数とかアバウトな情報だけ出すことにします。  
すでに解答済みの人は自分のコードとRubyのコードを比較するとわかりやすいと思います。  
行数と、制御構造関連の命令をカウントすると以下の様になりました

行数: 66行 (コメントを除いたmain部分)  
if: 6  
switch: 2  
case: 19  
for: 3  
break: 1  


## Rubyによる解答

{% highlight ruby %}
require 'date'
# ---- 事前処理
year, month = gets.split

first_day = Date.new(year.to_i, month.to_i)
last_day  = first_day.next_month - 1
days = (last_day - first_day).floor

# ---- 曜日表示
puts '|日|月|火|水|木|金|土|'

# ---- 空枠表示
first_day.wday.times {  print '|  ' }

# ---- 各日表示
(first_day..last_day).each do |date|
  print "|%2d"%date.day
  puts  "|" if date.saturday?
end

# ---- 空枠表示
unless last_day.saturday?
  (last_day..(last_day+7)).each do |date|
    break if date.saturday?
    print "|  "
  end
  puts "|"
end
{% endhighlight %}

こんなかんじになりました。Rubyらしく処理すればもっと違った書き方になったりするでしょうが、今回はC言語での解法をなぞる感じで書いています。  
比較してみると  

行数: 25  
if: 3    (if, unless)  
for: 4   (Range, each)  
break: 1  

分岐が減ってスッキリかかけていると思います。コードの中身も特に頭を捻って考えないといけないようなコードがなく、シンプルに見えるはず。
便利！！キレイ！

# まとめ

Ruby便利！！  
使いましょう！！！

